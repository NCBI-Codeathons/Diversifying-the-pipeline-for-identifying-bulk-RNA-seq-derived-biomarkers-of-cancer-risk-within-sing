---
title: "integration-seurat"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{bash wget count data}
wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758471_PJ016.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758472_PJ017.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758473_PJ018.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758474_PJ025.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758475_PJ030.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758476_PJ032.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2758477_PJ035.filtered.matrix.txt.gz

wget https://github.com/NCBI-Codeathons/Identifying-bulk-RNA-seq-derived-biomarkers-of-cancer-risk-within-single-cell-populations/raw/master/data/GSE103224_RAW/GSM2940098_PJ048.filtered.matrix.txt.gz
```


```{r load libraries}
packages=c("SingleCellExperiment","scater","data.table","Seurat","batchelor","future","dplyr","scran","parallel")
invisible(lapply(packages, suppressWarnings(suppressMessages(require)), character.only = TRUE))
```


When you're integrating scRNA-seq datasets, starting with the count data is fine. QC them in parallel. Then, find shared gene expression.
```{r data ingestion, include=FALSE}
#get list of txt files
files <- list.files(path= "~/",pattern = "GSM*",full.names = T) 

#list of df stored in this var
dfs=list()

batch_list=c("PJ16","PJ17","PJ18","PJ25","PJ30","PJ32","PJ35","PJ48")


file_input <- function(filename,batch){

  print(paste("Reading:",filename))
  #read in text files containing count data
  #automatically gunzips
  df=data.table::fread(filename) 
  df=as.data.frame(df)
  
  #preprocess data table
  df=df[!duplicated(df[,2]),] #drop rows with duplicate gene names (dropping the second instance)
  row.names(df)=df[,2] #set ensembl id to row names (ensembl id are unique, but gene names aren't)
  df=df[,3:ncol(df)]
  
  return(df) 
}


#generate list of dataframes containing count data

dfs <- lapply(files, FUN=file_input,batch=batch_list)
#dfs <- clusterMap(cluster, file_input, filename=files,batch=batch_list)
```




```{r adding donor metadata to seurat object}
#seur.nom will be a list of seurat objects from each donor
seur.norm=ls()

for( i in 1:length(batch_list)){
current_donor= batch_list[i]

seur.norm[[i]] <- CreateSeuratObject(counts = dfs[[i]], min.cells = 3, min.features  = 100, )

seur.norm[[i]]= AddMetaData(seur.norm[[i]],
                metadata=currenti_donor,col.name="donor")
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
    seur.norm[[i]] <- NormalizeData(seur.norm[[i]], verbose = FALSE)

    #remove cells with high MT expression
    seur.norm[[i]]=subset(seur.norm[[i]], subset=nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt<5)
    seur.norm[[i]] <- FindVariableFeatures(seur.norm[[i]], selection.method = "vst",  nfeatures = 2000, verbose = FALSE)

}

#remove unnneeded variables
remove(dfs)
```




https://satijalab.org/seurat/v3.1/merge_vignette.html
```{r generate anchors and batch-correct}

#merging seurat objects isn't necessary, if you merge, you have to split again later anyway
#merge produces a raw data matrix
#add.cell.ids = appends parameters to the respective cell-names
#seur.combined=merge(x=seur.norm[[1]],y=seur.norm[2:4],add.cell.ids=c("PJ16","PJ17","PJ30","PJ32"), project="donor")
#donor.list <- SplitObject(seur.combined, split.by = "donor")
#reference.list <- donor.list[batch_list] 

#calculate anchors
anchors <- FindIntegrationAnchors(object.list = seur.norm, dims = 1:30)

#use anchors to generate new seurat object containing ASSAY with batch-corrected expression matrix
donors.integrated=IntegrateData(anchorset = anchors,dims=1:30)
#primary dataset is batch-corrected expression matrix
#a second dataset is also stored, the uncorrected values are stored in assay- RNA

```


```{r dim reduction and visualization on corrected data}
DefaultAssay(donors.integrated) <- "integrated"

#scale data before running PCA
donors.integrated <- ScaleData(donors.integrated, verbose = FALSE)

# Run the standard workflow for visualization and clustering
donors.integrated <- RunPCA(donors.integrated, npcs = 30, verbose = FALSE)
donors.integrated <- RunUMAP(donors.integrated, reduction = "pca", dims = 1:30)
donors.integrated <- RunTSNE(donors.integrated, reduction = "pca", dims = 1:30)

DimPlot(donors.integrated, reduction = "umap", group.by = "donor")
#DimPlot(donors.integrated, reduction = "tsne", group.by = "donor") 

```


first dataset= reference
additional datasets= queries

use cluster labels from reference, to label queries
```{r use }

donors.query= seur.norm[[2]]
donors.anchors <- FindTransferAnchors(reference = donors.integrated, query = donors.query, dims=1:30, project.query = T)

```


```{r defining clusters}
donors.integrated <- FindNeighbors(donors.integrated, dims = 1:10) # generates KNN graph
donors.integrated <- FindClusters(donors.integrated, resolution = 0.5) #louvain

#clusters can be accessed using Idents()
#cluster labels accessed via: levels(object)
```


```{r biomarkers for clusters }
#find markers for all clusters
integrated.markers <- FindAllMarkers(donors.integrated, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)

topmarker=integrated.markers %>% group_by(cluster) %>% top_n(n = 1, wt = avg_logFC)
```


```{r visualizing clusters with markers}
DimPlot(donors.integrated, reduction = "umap",group.by="donor")

#histogram for each cluster
RidgePlot(donors.integrated,features=topmarker$gene[6:10])

#dotplot: expression  + %age expressing 
DotPlot(donors.integrated,features=topmarker$gene) + RotatedAxis()

#Featureplot  #3d map with single gene heatmap


#heatmap with cluster abels and selected genes
DoHeatmap(donors.integrated, features = topmarker, size = 3)
```

```{r}
topmarker$gene

```

pangload db

cellmarker


```{r}

```


```{r}

```


```{r}

```


```{r}

```


```{r}

```


```{r}
saveRDS(donors.integrated,"seurat-integrated.rds")
```

